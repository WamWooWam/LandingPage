using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Serialization;

int indent = 0;
StreamWriter writer = null;

var styles = new Dictionary<string, Style>();
var usedStyles = new HashSet<string>();
var file = args.Length > 0 ? args[0] : @"C:\Users\Thomas\Desktop\win8\twinui\.rsrc\TILETEMPLATE\";
if (new DirectoryInfo(file).Exists)
{
    var list = new List<string>();
    foreach (var duixml in new DirectoryInfo(file).GetFiles("*.duixml"))
    {
        Console.WriteLine($"Processing {duixml.Name}");
        var name = ProcessFile(duixml.FullName);
        list.Add(name);
    }

    writer = File.CreateText("TileTemplates/index.scss");
    WriteAutoGeneratedHeader();
    foreach (var style in usedStyles)
    {
        WriteOpen($".{MakeCssName(styles[style].ResId)} {{");

        foreach (var property in GetCssPropertiesForStyle(styles[style]))
        {
            Write($"{property.key}: {property.value};");
        }

        WriteEnd();
    }

    writer.Close();


    writer = File.CreateText("TileTemplates/index.ts");
    WriteAutoGeneratedHeader();

    Write($"import './index.scss'");

    foreach (var name in list)
    {
        Write($"import {name} from './{name}'");
    }

    Write("");
    Write("const TileTemplates = {");
    foreach (var name in list)
    {
        Write($"    {name},");
    }
    Write("};");

    Write("export default TileTemplates;");
    writer.Close();
}
else
{
    ProcessFile(file);
}


string ProcessFile(string file)
{
    var document = new XmlDocument();
    document.Load(file);

    var root = document.DocumentElement!;
    var stylesheets = root.GetElementsByTagName("style");

    foreach (XmlElement stylesheet in stylesheets)
    {
        var id = stylesheet.GetAttribute("resid");
        var child = stylesheet.FirstChild!;
        var type = child.Name;
        var properties = new Dictionary<string, string>();
        foreach (XmlAttribute attribute in child.Attributes!)
        {
            properties.Add(attribute.Name, attribute.Value);
        }

        if (styles.TryGetValue(id, out var existing))
        {
            // check if the existing style is the same
            if (existing.Type != type || existing.Properties.Count != properties.Count)
            {
                throw new Exception($"Style {id} already exists with different type or properties");
            }
        }
        else
        {
            styles.Add(id, new Style(id, type, properties));
        }
    }

    var element = (root.SelectSingleNode("/duixml/NotificationElement") as XmlElement)!;
    var rootId = element.GetAttribute("resid")!;

    writer = File.CreateText("TileTemplates/" + MakeCssName(rootId) + ".scss");
    indent = 0;

    WriteAutoGeneratedHeader();
    WriteOpen($".{MakeCssName(rootId)} {{");

    foreach (XmlElement containers in element.ChildNodes)
    {
        var id = containers.GetAttribute("id")[5..^1];
        ProcessElementStyles(containers, usedStyles);
    }

    WriteEnd();

    writer.Close();

    writer = File.CreateText("TileTemplates/" + rootId + ".tsx");
    WriteAutoGeneratedHeader();

    Write($"import \"./{MakeCssName(rootId)}.scss\"");
    Write("import TileTemplateProps from '../TileTemplateProps'");
    Write("import TileNotificationBinding from '../TileNotificationBinding'");
    Write("import TileImageBinding from '../TileImageBinding'");
    Write("import TileTextBinding from '../TileTextBinding'");

    Write("");

    WriteOpen($"export default function {rootId}(props: TileTemplateProps) {{");

    foreach (XmlElement containers in element.ChildNodes)
    {
        ProcessElementBindings(containers, containers.GetAttribute("id")[5..^1], "");
    }

    Write("");
    WriteOpen($"return (");
    ProcessElement(element, rootId, "");
    WriteEnd(");");
    WriteEnd();

    writer.Close();

    return rootId;

    void ProcessElementBindings(XmlElement element, string parentType, string type)
    {
        var sheet = element.GetAttribute("sheet");
        var style = new Style("", "", new Dictionary<string, string>());
        if (!string.IsNullOrEmpty(sheet))
        {
            style = styles[sheet];
        }

        var id = 0;
        var name = element.GetAttribute("id")[5..^1];
        if (!name.All(char.IsNumber))
        {
            foreach (XmlElement child in element.ChildNodes)
            {
                ProcessElementBindings(child, type, name);
            }

            return;
        }

        id = int.Parse(name);

        var htmlElement = type == "Images" ? "TileImageBinding" : GetHTMLElement(element.Name);


        if (element.ChildNodes.Count != 0)
        {
            throw new Exception("shouldn't ever happen?");
        }
        else
        {
            var jsType = type == "Images" ? "image" : "text";
            Write($"const {jsType}{id} = props.elements.find(b => b.id === {id} && b.type === '{jsType}');");
        }
    }

    void ProcessElement(XmlElement element, string parentType, string type)
    {
        var sheet = element.GetAttribute("sheet");
        var style = new Style("", "", new Dictionary<string, string>());
        if (!string.IsNullOrEmpty(sheet))
        {
            style = styles[sheet];
        }

        var id = 0;
        var name = element.GetAttribute("id");
        if (!string.IsNullOrEmpty(name))
        {
            name = name[5..^1];
            if (name?.All(char.IsNumber) == true)
            {
                id = int.Parse(name);
                name = $"Id-{name}";
            }
        }
        else
        {
            name = parentType;
        }

        var cssName = "";
        if (!string.IsNullOrEmpty(style.ResId))
        {
            cssName += $"{MakeCssName(style.ResId)}";
        }

        cssName += $" {MakeCssName(name)}";
        cssName = cssName.Trim();

        var htmlElement = type == "Images" ? "TileImageBinding" : GetHTMLElement(element.Name);

        var props = new List<ReactProperty> { new ReactProperty("className", cssName, false) };
        props.AddRange(GetJSProperties(element));

        if (id != 0)
        {
            props.Add(new ReactProperty("binding", $"{(type == "Images" ? "image" : "text")}{id}", true));
        }

        var Props = string.Join(" ", props.Select(p => p.IsProp ? $"{p.Name}={{{p.Value}}}" : $"{p.Name}=\"{p.Value}\""));

        if (element.ChildNodes.Count != 0)
        {
            WriteOpen($"<{htmlElement} {Props}>");
            foreach (var child in element.ChildNodes)
            {
                if (child is XmlText text)
                {
                    Write(text.Value);
                }
                else if (child is XmlElement childElement)
                {
                    ProcessElement(childElement, type, name);
                }
            }
            WriteEnd($"</{htmlElement}>");
        }
        else
        {
            Write($"<{htmlElement} {Props} />");
        }
    }

    void ProcessElementStyles(XmlElement element, HashSet<string> usedStyles)
    {
        var sheet = element.GetAttribute("sheet");
        var style = new Style("", "", new Dictionary<string, string>());
        if (!string.IsNullOrEmpty(sheet))
        {
            usedStyles.Add(sheet);
        }

        var name = element.GetAttribute("id")[5..^1];
        if (name.All(char.IsNumber))
        {
            name = $"Id-{name}";
        }

        var cssName = MakeCssName(name);
        WriteOpen($".{cssName} {{");

        foreach (var (key, value) in GetCssProperties(element))
        {
            Write($"{key}: {value};");
        }

        foreach (XmlElement child in element.ChildNodes)
        {
            ProcessElementStyles(child, usedStyles);
        }

        WriteEnd();
    }
}

IEnumerable<ReactProperty> GetJSProperties(XmlElement element)
{
    foreach (XmlAttribute attribute in element.Attributes!)
    {
        switch (attribute.Name)
        {
            // handled by CSS
            case "width":
            case "height":
            case "x":
            case "y":
            case "layoutpos":
            case "font":
            case "linespacing":
            case "alpha":
            case "contentalign":
            case "typography":
            case "id":
            case "sheet":
            case "visible":
            case "resid":
            case "layout":
            case "background":
                break;

            case "peekmargin":
            case "logomargins":
            case "badgemargins":
            case "logoandbadgemargins":
                {
                    var match = RECT.Match(attribute.Value);
                    var values = match.Groups.Values.Skip(1).Select(g => (int)(int.Parse(g.Value) * 0.8)).ToArray();
                    if (match.Success)
                    {
                        yield return new(TransformDuiNameToJS(attribute.Name), $"{{left: {values[0]}, top: {values[1]}, right: {values[2]}, bottom: {values[3]}}}", true);
                    }
                    break;
                }

            case "forcebadgeplate":
            case "dynamicformat":
                yield return new(TransformDuiNameToJS(attribute.Name), attribute.Value.ToLowerInvariant() == "on" ? "true" : "false", true);
                break;

            case "singlelineyoffset":
                yield return new(TransformDuiNameToJS(attribute.Name), ConvertRPtoPx(attribute.Value), false);
                break;

            case "class":
                if (attribute.Value == "BottomUpText")
                    yield return new("isBottomUp", "true", true);
                break;
            default:
                yield return new(TransformDuiNameToJS(attribute.Name), attribute.Value, true);
                break;
        }
    }
}

string TransformDuiNameToJS(string attributeName)
{
    return attributeName.ToLowerInvariant() switch
    {
        "dynamicformat" => "dynamicFormat",
        "forcebadgeplate" => "forceBadgePlate",
        "singlelineyoffset" => "singleLineYOffset",
        "logomargins" => "logoMargins",
        "badgemargins" => "badgeMargins",
        "logoandbadgemargins" => "logoAndBadgeMargins",
        "secondaryimageid" => "secondaryImageId",
        "peekmargin" => "peekMargin",
        _ => attributeName
    };
}


IEnumerable<(string key, string value)> GetCssProperties(XmlElement element)
{
    foreach (XmlAttribute attribute in element.Attributes!)
    {
        foreach (var val in TransformDuiPropertyToCSS(attribute.Name, attribute.Value))
            yield return val;
    }
}

IEnumerable<(string key, string value)> GetCssPropertiesForStyle(Style style)
{
    foreach (var x in style.Properties)
    {
        foreach (var val in TransformDuiPropertyToCSS(x.Key, x.Value))
            yield return val;
    }
}

IEnumerable<(string key, string value)> TransformDuiPropertyToCSS(string name, string value)
{
    switch (name)
    {
        case "width":
        case "height":
            yield return (name, ConvertRPtoPx(value)); break;
        case "x":
            yield return ("left", ConvertRPtoPx(value)); break;
        case "y":
            yield return ("top", ConvertRPtoPx(value)); break;
        case "layoutpos":
            yield return ("position", value switch
            {
                "absolute" => "absolute",
                _ => "relative"
            });
            break;
        case "font":
            {
                var font = value.Split(';');
                if (!string.IsNullOrEmpty(font[0]))
                    yield return ("font-size", $"{Math.Round(int.Parse(font[0]) * 0.8)}pt");

                break;
            }
        case "linespacing":
            yield return ("line-height", ConvertRPtoPx(value)); break;

        case "alpha":
            yield return ("opacity", $"{int.Parse(value) / 255.0}"); ;
            yield return ("background-color", "black");
            break;

        case "contentalign":
            {
                var splits = value.Split('|').Select(s => s.Trim()).ToArray();
                foreach (var split in splits)
                {
                    switch (split)
                    {
                        case "topright":
                            yield return ("text-align", "right"); break;
                        case "bottomleft":
                            yield return ("text-align", "left"); break;
                    }
                }
                break;
            }

        case "typography":
            {
                var splits = value.Split(',');
                yield return ("font-feature-settings", string.Join(',', splits.Select(s => $"'{s.Split('=')[0]}' {s.Split('=')[1]}")));
                break;
            }

        case "id":
        case "sheet":
        case "visible":
            break;


        default:
            Console.WriteLine($"Unknown property: {name}"); break;

    }
}

string GetHTMLElement(string element)
{
    switch (element)
    {
        case "RichText":
            return "TileTextBinding";
        case "NotificationElement":
            return "TileNotificationBinding";
        case "element":
        default:
            return "div";
    }
}

string ConvertRPtoPx(string rpValue)
{
    // convert 310rp to 248px
    if (int.TryParse(rpValue, out _)) return rpValue;

    var rp = int.Parse(rpValue[..^2]);
    var px = (int)(rp * 0.8);
    return $"{px}px";
}
string MakeCssName(string name)
{
    return CSS.Replace(name, "-$1").ToLower().Trim('-');
}

void Write(string line)
{
    writer.WriteLine($"{new string(' ', indent * 4)}{line}");
}

void WriteOpen(string line)
{
    Write(line);
    indent++;
}

void WriteEnd(string line = "}")
{
    indent--;

    Write(line);
}

void WriteAutoGeneratedHeader()
{
    Write($"//------------------------------------------------------------------------------");
    Write($"// <auto-generated>");
    Write($"//     This code was generated by a tool.");
    Write($"//     Runtime Version:{RuntimeEnvironment.GetSystemVersion()}");
    Write($"//");
    Write($"//     Changes to this file may cause incorrect behavior and will be lost if");
    Write($"//     the code is regenerated.");
    Write($"// </auto-generated>");
    Write($"//------------------------------------------------------------------------------");
    Write($"");
}

record class Style(string ResId, string Type, Dictionary<string, string> Properties);

record class ReactProperty(string Name, string Value, bool IsProp = false);

partial class Program
{
    [GeneratedRegex(@"rect\(([0-9]+)rp,([0-9]+)rp,([0-9]+)rp,([0-9]+)rp\)")]
    private static partial Regex _RECT();
    [GeneratedRegex("([A-Z])")]
    private static partial Regex _CSS();

    public static Regex RECT => _RECT();
    public static Regex CSS => _CSS();
}